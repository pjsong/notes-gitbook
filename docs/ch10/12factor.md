# [来源](https://12factor.net/)

## 介绍

当今软件基本都是服务的形式，如webapp或者saas， 12因素app为构建saas提供方法论。saas的特征如下：

1. 声明式的安装自动化，来降低新开发者的时间成本
2. 与操作系统有清晰的合约，提供不同执行环境下做大的可移植性
3. 适合现代云平台部署，避免服务器和系统管理
4. 最小化开发和生产环境的不一致，支持持续部署来最大化敏捷方法。
5. 无需有工具，架构或者开发上打的变更，来进行扩展

## 12因子

+ 代码库有版本跟踪，一个版本，多个部署。
  + 一个代码库对应一个应用，如果有多个代码库，那就不是app,是分布式系统。分布式系统的组件就是app,每个app都适用12因子。
  + 部署是一个app的运行实例。每个开发者有自己本地的拷贝运行，这也是一个合格的部署。
  + 对于所有的部署每个库都一样，只是可能版本不同。比如开发者本地的提交可能没有部署到stage, stage的提交可能没有部署到prd。但他们共享同一代码库，只是部署不同
+ 明确声明和隔离依赖。开发者只需要checkout代码库，语言运行环境，依赖管理器就能够进入开发。Ruby有Gemfile来声明依赖，bundle exec来隔离依赖。Python中pip用来声明依赖，virtualEnv来隔离依赖。声明和隔离必须同时存在. app不以来任何系统工具比如curl,ImageMagic.
+ 配置全部进入环境中，而不能在代码中。
  + 判断一个应用是否正确地将配置排除在代码之外，一个简单的方法是看该应用的基准代码是否可以立刻开源，而不用担心会暴露任何敏感的信息。
  + 如果在不同部署间不存在差异，应该写入代码。
  + 推荐将应用的配置存储于环境变量中。不建议进入代码库，因为不方便查看和管理。不建议分组比如prd,dev,test，这样可能导致组合爆炸，让管理部署变得麻烦。而环境变量是粒度控制，他们不会组合成一个环境，而是被每个部署独立管理.
+ 后端服务当作资源
  + 第三方和本地服务没有区别。
  + 部署可以按需加载或卸载资源
+ 构建/发布/运行严格分开
  + 构建将代码仓库转化为可执行包。构建时会使用指定版本的代码，获取和打包 依赖项，编译成二进制文件和资源文件
  + 发布将构建的结果和当前部署的配置相结合，并能够立刻在运行环境中投入使用
  + 运行指针对选定的发布版本，在执行环境中启动一系列应用程序 进程
  + 每一个发布版本必须对应一个唯一的发布 ID，例如可以使用发布时的时间戳（2011-04-06-20:32:17），亦或是一个增长的数字（v100）。发布的版本就像一本只能追加的账本，一旦发布就不可修改，任何的变动都应该产生一个新的发布版本。
  + 相应工具参考jenkins,CircleCI[其他](https://dzone.com/articles/21-automated-deployment-tools-you-should-know)
+ 把app当作一个或者多个无状态进程
  + 应用的进程必须无状态，适用无共享架构，任何需要持久化的数据都要存储在后端服务。
  + 无共享是一种分布式架构,每个节点独立且自洽，系统内无单点竞争.与应用服务器或者数据库服务器等中心存储信息的系统对比，没有了单点故障，可以平滑升级
  + 一些互联网系统依赖于 “粘性 session”， 这是指将用户 session 中的数据缓存至某进程的内存中，并将同一用户的后续请求路由到同一个进程。粘性sticky session 是 12-Factor 极力反对的。Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中。
+ 通过端口绑定输出服务
  + 有时webapp在容器运行，但app完全自包含，而不依赖于任何网络服务器就可以创建一个面向网络的服务。
  + 互联网应用 通过端口绑定来提供服务 ，并监听发送至该端口的请求。通常的实现思路是，将网络服务器类库通过依赖声明载入应用
  + 完全由应用的代码发起请求。和运行环境约定好绑定的端口即可处理这些请求
  + 端口绑定这种方式也意味着一个应用可以成为另外一个应用的后端服务 ，调用方将服务方提供的相应URL当作资源存入配置 以备将来调用
+ 并发处理。通过进程模型水平扩展。app有个Procfile,如procType：commandToRun. procType除了web特殊(自动把http请求转给web类型），可以是任意的
+ 可处理。启动时间最小，收到SIGTERM信号优雅关闭
  + 对于web就是停止监听端口，等其他请求完成之后再退出.
  + 对于worker进程，就是把工作返回给队列。
  + 对于硬件故障，就是做一个排队后台，一旦客户端超时就把工作还给队列。
+ 尽可能把开发，准生产，生产环境弄得一样。反对在不同环境间使用不同的后端服务
+ 把日志当作事件流。
  + 应用本身从不考虑存储自己的输出流.不应该试图去写或者管理日志文件。相反，每一个运行的进程都会直接的标准输出（stdout）事件流。开发环境中，开发人员可以通过这些数据流，实时在终端看到应用的活动
  + 在预发布或线上部署中，每个进程的输出流由运行环境截获，并将其他输出流整理在一起，然后一并发送给一个或多个最终的处理程序，用于查看或是长期存档。这些存档路径对于应用来说不可见也不可配置，而是完全交给程序的运行环境管理。类似 Logplex 和 Fluentd 的开源工具可以达到这个目的
  + 这些事件流可以输出至文件，或者在终端实时观察。最重要的，输出流可以发送到 Splunk 这样的日志索引及分析系统，或Hadoop/Hive 这样的通用数据存储系统。这些系统为查看应用的历史活动提供了强大而灵活的功能，包括：
    + 找出过去一段时间特殊的事件。
    + 图形化一个大规模的趋势，比如每分钟的请求量。
    + 根据用户定义的条件实时触发警报，比如每分钟的报错超过某个警戒线
+ 管理进程应该用一次性进程，比如用REPL(read-eval-print-loop) shell脚本.